%{

open AlgoMove.Transpiler.Absyn

open FSharp.Common
open FSharp.Common.Parsing.LexYacc
open AlgoMove.Transpiler 
open AlgoMove.Transpiler.Absyn.Move

let parse_error_rich = Some (fun ctx -> raise (ParseErrorContextException ctx))

%}
 

%token <System.String> NUM
%token <System.String> ID

%token MODULE STRUCT HAS COPY DROP KEY STORE PUBLIC ENTRY USE NATIVE
       U8 U64 U128 BOOL ADDRESS AMP MUT STAR
       BRA KET SQBRA SQKET CURBRA CURKET
       COLON DOT COMMA COLON2 SEMICOLON
       MOVLOC CPYLOC STLOC CALL 
       LDU8 LDU128 LDU64 LDCONST LDTRUE LDFALSE
       BRANCH BRTRUE BRFALSE NOP
       ADD SUB MUL DIV MOD EQ NEQ LT LE GT GE BOR BAND OR AND XOR NOT SHL SHR POP ABORT
       READREF WRITEREF FREEZEREF 
       RET VECLEN
       BORROWLOC BORROWFIELD BORROWGLOBAL 
       PACK UNPACK EXISTS MOVETO MOVEFROM
%token EOF


%type < AlgoMove.Transpiler.Absyn.Move.Module > Module

%start Module

%%

Module: 
    MODULE qid CURBRA
        imports
        structs
        funs
    CURKET EOF                  { { fullname = $2; imports = $4; structs = $5; funs = $6 } }

imports:
    imports_                    { $1 }
  |                             { [] }

imports_:
  | import                      { [$1] }
  | import imports_             { $1 :: $2 }

import:
    USE qid SEMICOLON           { $2 }

structs:
    structs_                    { $1 }
  |                             { [] }

structs_:
    structt                     { [$1] }
  | structt structs_            { $1 :: $2 }
  
structt:
    STRUCT ID has_capabs CURBRA
    fields CURKET               { { id = $2; capabs = $3; fields = $5 } }

has_capabs: 
    HAS capabs                  { $2 }
  |                             { [] }

fields:
    args                        { $1 }

funs:
    funn                        { [$1] }
  | funn funs                   { $1 :: $2 }
 
funn:
    quals ID BRA args KET
    return_ty
    optbody                     { { quals = $1; id = $2; args = $4; ret = $6; body = List.toArray $7 } }   

optbody:
    CURBRA body CURKET          { $2 }
  |                             { [] }

arg:
    ID COLON ty                 { $1, $3 }

args:
    arg                         { [$1] }
  |                             { [] }
  | arg COMMA args              { $1 :: $3 }

body:
    bodyline                    { $1 }
  | bodyline body               { $1 @ $2 }

bodyline:
    label COLON opcode          { [$3] }
  | ID COLON                    { [] }          // skipped
  | ty                          { [] }          // skipped

quals:
    qual                        { [$1] }
  | qual quals                  { $1 :: $2 }

qual:
    PUBLIC                      { qual.Public }
  | ENTRY                       { qual.Entry }
  | NATIVE  				    { qual.Native }    

return_ty:
    COLON ty                    { Some $2 }
  |                             { None }
  | COLON ty_tuple              { Some (ty.Tuple $2) }    /* tuples can only be in return types */

ty:
    U8                          { ty.U8 }
  | U64                         { ty.U64 }
  | BOOL                        { ty.Bool }
  | ADDRESS                     { ty.Address }
  | ID                          { ty.Typename $1 }
  | AMP ty                      { ty.Ref $2 }
  | AMP MUT ty                  { ty.MutRef $3 }

ty_tuple:
  | ty STAR ty                  { [$1; $3] }    /* disassambled tuple types have STAR not COMMA */
  | ty STAR ty_tuple            { $1 :: $3 }

capabs:
    capab                       { [$1] }
  | capab COMMA capabs          { $1 :: $3 }

capab:
  | COPY                        { Copy }
  | DROP                        { Drop }
  | KEY                         { Key }
  | STORE                       { Store }
 
qid:
    ID                          { None, $1 }
  | ID COLON2 ID			    { Some $1, $3 }  
  | ID DOT ID			        { Some $1, $3 }     
  | NUM DOT ID			        { None, $3 }     
  | NUM COLON2 ID		        { None, $3 }     

tys:
    ty                          { [$1] }
  | ty COMMA tys                { $1 :: $3 }

index:
    NUM                         { byte $1 }

label:
    NUM                         { uint $1 }

argtys:
    tys                         { $1 }
  |                             { [] }



opcode:
    opcodes_no_imm                                          { $1 }
  | opcodes_index SQBRA index SQKET BRA ID COLON ty KET     { $1 $3 }
  | opcodes_label BRA label KET                             { $1 $3 }
  | opcode_typename SQBRA index SQKET BRA ID KET            { $1 $6 }

  | BORROWFIELD SQBRA index SQKET BRA ID DOT ID COLON ty KET   { BorrowField ($6, $8, $10) }

  | CALL qid BRA argtys KET return_ty                       { Call ($2, $4, $6) }
  | LDU8 BRA NUM KET                                        { LdU8 (byte $3) }
  | LDU64 BRA NUM KET                                       { LdU64 (uint64 $3) }
  | LDU128 BRA NUM KET                                      { LdU128 (System.UInt128.Parse $3) }
  | LDCONST SQBRA NUM SQKET BRA const KET                   { LdConst $6 }   
  | VECLEN BRA index KET                                    { VecLen $3 }

const:
    const_ty COLON SQBRA nums SQKET    { ty.of_const_ty $1, $4 }

const_ty:
    ID						    { $1, None }   
  | ID BRA ID KET               { $1, Some $3 } 
 
nums:
    NUM                         { [int $1] }
  | NUM COMMA nums              { int $1 :: $3 }

opcode_typename:
  | PACK                        { Pack }
  | UNPACK                      { Unpack }
  | BORROWGLOBAL                { BorrowGlobal }
  | EXISTS                      { Exists }
  | MOVETO                      { MoveTo }
  | MOVEFROM                    { MoveFrom }


opcodes_index:
    MOVLOC                      { MovLoc }  
  | CPYLOC                      { CpyLoc }
  | STLOC                       { StLoc }
  | BORROWLOC                   { BorrowLoc }

opcodes_label:
    BRANCH                      { fun l -> Br (None, l) }  
  | BRTRUE                      { fun l -> Br (Some true, l) }  
  | BRFALSE                     { fun l -> Br (Some false, l) }  

opcodes_no_imm:
    NOP										      { Nop }
  | ADD                                           { Add }
  | SUB                                           { Sub }
  | MUL                                           { Mul }
  | DIV                                           { Div }
  | MOD                                           { Mod }
  | EQ                                            { Eq }
  | NEQ                                           { Neq }
  | LT                                            { Lt }
  | LE                                            { Le }
  | GT                                            { Gt }
  | GE                                            { Ge }
  | BOR                                           { BOr }        
  | BAND                                          { BAnd }        
  | OR											  { Or }
  | AND										      { And }
  | XOR                                           { Xor }
  | NOT                                           { Not }
  | SHL                                           { Shl }
  | SHR                                           { Shr }  
  | POP                                           { Pop }
  | ABORT                                         { Abort }

  | READREF                                       { ReadRef }
  | WRITEREF                                      { WriteRef }
  | FREEZEREF                                     { FreezeRef }

  | LDTRUE                                        { LdBool true }
  | LDFALSE                                       { LdBool false }
  | RET                                           { Ret }
  
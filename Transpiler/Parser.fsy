%{

open AlgoMove.Transpiler.Absyn

open FSharp.Common
open FSharp.Common.Parsing.LexYacc
open AlgoMove.Transpiler 
open AlgoMove.Transpiler.Absyn.Move

let parse_error_rich = Some (fun ctx -> raise (ParseErrorContextException ctx))

%}
 

%token <System.String> NUM
%token <System.String> ID

%token MODULE STRUCT HAS COPY DROP KEY STORE PUBLIC ENTRY
       U8 U64 U128 BOOL ADDRESS AMP MUT STAR
       BRA KET SQBRA SQKET CURBRA CURKET
       COLON DOT COMMA 
       MOVLOC CPYLOC STLOC CALL 
       LDU8 LDU128 LDU64 LDCONST LDTRUE LDFALSE
       BRANCH BRTRUE BRFALSE NOP
       ADD SUB MUL DIV MOD EQ NEQ LT LE GT GE BOR BAND OR AND XOR NOT SHL SHR POP ABORT
       READREF WRITEREF FREEZEREF 
       RET
       IMMBORROWLOC MUTBORROWLOC IMMBORROWFIELD MUTBORROWFIELD IMMBORROWGLOBAL MUTBORROWGLOBAL
       PACK UNPACK EXISTS MOVETO MOVEFROM
%token EOF


%type < AlgoMove.Transpiler.Absyn.Move.program > program

%start program

%%

program: 
    MODULE qid CURBRA
        structs
        funs
    CURKET EOF                  { { qid = $2; structs = $4; funs = $5 } }
  | MODULE qid CURBRA
        funs
    CURKET EOF                  { { qid = $2; structs = []; funs = $4 } }

structs:
    structt                     { [$1] }
  | structt structs             { $1 :: $2 }
  
structt:
    STRUCT ID CURBRA
    fields CURKET               { { id = $2; capabs = []; fields = $4 } }
  | STRUCT ID
    HAS capabs CURBRA
    fields CURKET               { { id = $2; capabs = $4; fields = $6 } }

fields:
    args                        { $1 }

funs:
    funn                        { [$1] }
/*  |                             { [] }*/
  | funn funs                   { $1 :: $2 }
 
funn:
    quals ID BRA args KET
    return_ty
    CURBRA body CURKET          { { quals = $1; id = $2; args = $4; ret = $6; body = $8 } }   

arg:
    ID COLON ty                 { $1, $3 }

args:
    arg                         { [$1] }
  |                             { [] }
  | arg COMMA args              { $1 :: $3 }

body:
    bodyline                    { [$1] }
  | bodyline body               { $1 :: $2 }

bodyline:
    label COLON opcode          { $1, $3 }

quals:
    qual                        { [$1] }
  | qual quals                  { $1 :: $2 }

qual:
    PUBLIC                      { Public }
  | ENTRY                       { Entry }

return_ty:
    COLON ty                    { Some $2 }
  |                             { None }
  | COLON ty_tuple              { Some (ty.Tuple $2) }    /* tuples can only be in return types */

ty:
    U8                          { ty.U8 }
  | U64                         { ty.U64 }
  | BOOL                        { ty.Bool }
  | ADDRESS                     { ty.Address }
  | ID                          { ty.StructName $1 }
  | AMP ty                      { ty.Ref $2 }
  | AMP MUT ty                  { ty.MutRef $3 }

ty_tuple:
  | ty STAR ty                  { [$1; $3] }    /* disassambled tuple types have STAR not COMMA */
  | ty STAR ty_tuple            { $1 :: $3 }

capabs:
    capab                       { [$1] }
  | capab COMMA capabs          { $1 :: $3 }

capab:
  | COPY                        { Copy }
  | DROP                        { Drop }
  | KEY                         { Key }
  | STORE                       { Store }
 
qid:
    ID                          { [$1] }      
  | ID DOT qid                  { $1 :: $3 }

label:
    ID                          { $1 }
  | NUM                         { $1 }            

tys:
    ty                          { [$1] }
  | ty COMMA tys                { $1 :: $3 }

index:
    NUM                         { byte $1 }

opcode:
    ID COLON ty                                             { Nop }
  |                                                         { Nop }

  | opcodes_no_imm                                          { $1 }
  | opcodes_index SQBRA index SQKET BRA ID COLON ty KET     { $1 $3 }
  | opcodes_label BRA label KET                             { $1 $3 }
  | opcode_typename SQBRA index SQKET BRA ID KET            { $1 $6 }

  | opcode_borrowfield SQBRA index SQKET BRA ID DOT ID COLON ty KET   { BorrowField ($6, $8, $10) }

  | CALL ID BRA tys KET return_ty                           { Call ($2, $4, $6) }
  | LDU8 BRA NUM KET                                        { LdU8 (byte $3) }
  | LDU64 BRA NUM KET                                       { LdU64 (uint64 $3) }
  | LDU128 BRA NUM KET                                      { LdU128 (System.UInt128.Parse $3) }

opcode_borrowfield:
  | IMMBORROWFIELD          { BorrowField }
  | MUTBORROWFIELD          { BorrowField }
  
opcode_typename:
  | PACK                        { Pack }
  | UNPACK                      { Unpack }
  | IMMBORROWGLOBAL             { BorrowGlobal }
  | MUTBORROWGLOBAL             { BorrowGlobal }
  | EXISTS                      { Exists }
  | MOVETO                      { MoveTo }
  | MOVEFROM                    { MoveFrom }


opcodes_index:
    MOVLOC                      { MovLoc }  
  | CPYLOC                      { CpyLoc }
  | STLOC                       { StLoc }
  | IMMBORROWLOC                { BorrowLoc }
  | MUTBORROWLOC                { BorrowLoc }
  | LDCONST                     { LdConst }   

opcodes_label:
    BRANCH                      { fun l -> Br (None, l) }  
  | BRTRUE                      { fun l -> Br (Some true, l) }  
  | BRFALSE                     { fun l -> Br (Some false, l) }  

opcodes_no_imm:
    NOP										      { Nop }
  | ADD                                           { Add }
  | SUB                                           { Sub }
  | MUL                                           { Mul }
  | DIV                                           { Div }
  | MOD                                           { Mod }
  | EQ                                            { Eq }
  | NEQ                                           { Neq }
  | LT                                            { Lt }
  | LE                                            { Le }
  | GT                                            { Gt }
  | GE                                            { Ge }
  | BOR                                           { BOr }        
  | BAND                                          { BAnd }        
  | OR											  { Or }
  | AND										      { And }
  | XOR                                           { Xor }
  | NOT                                           { Not }
  | SHL                                           { Shl }
  | SHR                                           { Shr }  
  | POP                                           { Pop }
  | ABORT                                         { Abort }

  | READREF                                       { ReadRef }
  | WRITEREF                                      { WriteRef }
  | FREEZEREF                                     { FreezeRef }

  | LDTRUE                                        { LdBool true }
  | LDFALSE                                       { LdBool false }
  | RET                                           { Ret }
  